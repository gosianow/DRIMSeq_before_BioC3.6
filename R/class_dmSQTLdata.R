#' @include class_MatrixList.R
NULL

################################################################################
### dmSQTLdata class
################################################################################

#' dmSQTLdata object
#' 
#' dmSQTLdata contains genomic feature expression (counts), genotypes and sample information needed for the sQTL analysis. It can be created with function \code{\link{dmSQTLdataFromRanges}} or \code{\link{dmSQTLdata}}.
#' 
#' @return 
#' 
#' \itemize{
#'   \item \code{names(x)}: Get the gene names.
#'   \item \code{length(x)}: Get the number of genes.
#'   \item \code{x[i, j]}: Get a subset of dmDSdata object that consists of counts, genotypes and blocks corresponding to genes i and samples j. 
#' }
#' 
#' @param x dmSQTLdata object.
#' @param i,j Parameters used for subsetting.
#' 
#' @slot counts \code{\linkS4class{MatrixList}} of expression, in counts, of genomic features. Rows correspond to genomic features, such as exons or transcripts. Columns correspond to samples. MatrixList is partitioned in a way that each of the matrices in a list contains counts for a single gene.
#' @slot genotypes MatrixList of unique genotypes. Rows correspond to blocks, columns to samples. Each matrix in this list is a collection of unique genotypes that are matched with a given gene.
#' @slot blocks MatrixList with two columns \code{block_id} and \code{snp_id}. For each gene, it identifies SNPs with identical genotypes across the samples and assigns them to blocks.
#' @slot samples Data frame with information about samples. It contains unique sample names \code{sample_id}.
#' 
#'  @examples 
#' d <- dataSQTL_dmSQTLdata
#' head(names(d))
#' length(d)
#' d[1:10, ]
#' d[1:10, 1:10]
#' 
#' @author Malgorzata Nowicka
#' @seealso \code{\link{dataSQTL_dmSQTLdata}}, \code{\linkS4class{dmSQTLdispersion}}, \code{\linkS4class{dmSQTLfit}}, \code{\linkS4class{dmSQTLtest}} 
setClass("dmSQTLdata", 
         representation(counts = "MatrixList", 
                        genotypes = "MatrixList", 
                        blocks = "MatrixList",
                        samples = "data.frame"))


###################################


setValidity("dmSQTLdata", function(object){
  # has to return TRUE when valid object!
  
  if(!ncol(object@counts) == ncol(object@genotypes))
    return(paste0("Unequal number of samples in 'counts' and 'genotypes' ", ncol(object@counts), " and ", ncol(object@genotypes)))
  
  ### Mystery: This does not pass
#   if(!all(colnames(object@blocks) %in% c("block_id", "snp_id")))
#     return(paste0("'blocks' must contain 'block_id' and 'snp_id' variables"))
  
  if(!all(names(object@counts) == names(object@genotypes)))
    return(paste0("'genotypes' and 'counts' do not contain the same genes"))
  
  if(!all(names(object@blocks) == names(object@genotypes)))
    return(paste0("'genotypes' and 'blocks' do not contain the same genes or SNPs"))
  
  return(TRUE)
  
})


################################################################################
### accessing and subsetting methods
################################################################################


setMethod("show", "dmSQTLdata", function(object){
  
  cat("An object of class", class(object), "\n")
  
  cat("with", length(object), "genes and", ncol(object@counts), "samples\n")
  
})



###############################

#' @rdname dmSQTLdata-class
#' @export
setMethod("names", "dmSQTLdata", function(x) names(x@counts) )

#' @rdname dmSQTLdata-class
#' @export
setMethod("length", "dmSQTLdata", function(x) length(x@counts) )


#' @aliases [,dmSQTLdata-method
#' @rdname dmSQTLdata-class
#' @export
setMethod("[", "dmSQTLdata", function(x, i, j){
  
  if(missing(j)){
    
    counts <- x@counts[i, , drop = FALSE]
    genotypes <- x@genotypes[i, , drop = FALSE]
    blocks <- x@blocks[i, , drop = FALSE]
    samples <- x@samples
    
  }else{
    
    counts <- x@counts[i, j, drop = FALSE]
    genotypes <- x@genotypes[i, j, drop = FALSE]
    blocks <- x@blocks[i, , drop = FALSE]
    samples <- x@samples
    rownames(samples) <- samples$sample_id
    samples <- samples[j, , drop = FALSE]
    samples$sample_id <- factor(samples$sample_id)
    rownames(samples) <- NULL
    
  }
  
  return(new("dmSQTLdata", counts = counts, genotypes = genotypes, blocks = blocks, samples = samples))
  
})

################################################################################
### dmSQTLdata
################################################################################

#'  Create dmSQTLdata object 
#'  
#'  Constructor functions for a \code{\linkS4class{dmSQTLdata}} object. dmSQTLdata requires that SNPs are already matched to corresponding genes. dmSQTLdataFromRanges does the matching by assigning to a gene all the SNPs that are located in a given surrounding (\code{window}) of this gene.
#'  
#'  @details 
#'  It is quite common that sample grouping defined by some of the SNPs is identical. Compare \code{dim(genotypes)} and \code{dim(unique(genotypes))}. In our sQTL analysis, we do not repeat tests for the SNPs that define the same grouping of samples. Each grouping is tested only once. SNPs that define such unique groupings are aggregated into blocks. P-values and adjusted p-values are estimated at the block level, but the returned results are extended to a SNP level by repeating the block statistics for each SNP that belongs to a given block.
#'  
#'  @inheritParams dmDSdata
#'  @param genotypes Numeric matrix with genotypes. Rows represent SNPs, columns represent samples. The genotype of each sample is coded in the following way: 0 for ref/ref, 1 for ref/not ref, 2 for not ref/not ref, -1 or \code{NA} for missing value.
#'  @param gene_id_genotypes Vector of gene IDs corresponding to \code{genotypes}.
#'  @param snp_id Vector of SNP IDs corresponding to \code{genotypes}.
#'  @param BPPARAM Parallelization method used by \code{\link[BiocParallel]{bplapply}}.
#'  @return Returns a \code{\linkS4class{dmSQTLdata}} object.
#'  @examples 
#'  ### sQTL analysis
#'  ### Create dmSQTLdata object
#'  
#'  # counts
#'  head(dataSQTL_counts)
#'  # gene_ranges
#'  dataSQTL_gene_ranges
#'  # genotypes 
#'  head(dataSQTL_genotypes)
#'  
#'  ## gene_ranges with names!
#'  gene_ranges <- dataSQTL_gene_ranges
#'  names(gene_ranges) <- S4Vectors::mcols(gene_ranges)$name
#'  
#'  ## snp_ranges with names!
#'  snp_ranges <- GenomicRanges::GRanges(S4Vectors::Rle(dataSQTL_genotypes$chr), 
#'    IRanges::IRanges(dataSQTL_genotypes$start, dataSQTL_genotypes$end))
#'  names(snp_ranges) <- dataSQTL_genotypes$snp_id 
#'  
#'  ## Check if samples in count and genotypes are in the same order
#'  all(colnames(dataSQTL_counts[, -(1:2)]) == colnames(dataSQTL_genotypes[, -(1:4)]))
#'  sample_id <- colnames(dataSQTL_counts[, -(1:2)])
#'  
#'  d <- dmSQTLdataFromRanges(counts = dataSQTL_counts[, -(1:2)], 
#'    gene_id = dataSQTL_counts$gene_id, feature_id = dataSQTL_counts$transcript_id, 
#'    gene_ranges = gene_ranges, genotypes = dataSQTL_genotypes[, -(1:4)], 
#'    snp_id = dataSQTL_genotypes$snp_id, snp_ranges = snp_ranges, 
#'    sample_id = sample_id, window = 5e3, 
#'    BPPARAM = BiocParallel::MulticoreParam(workers = 1))
#'  
#'  plotData(d)
#'  
#'  @seealso \code{\link{dataSQTL_counts}}, \code{\link{dataSQTL_gene_ranges}}, \code{\link{dataSQTL_genotypes}}, \code{\link{dmFilter}}, \code{\link{dmDispersion}}, \code{\link{dmFit}}, \code{\link{dmTest}}
#'  @author Malgorzata Nowicka
#'  @export
dmSQTLdata <- function(counts, gene_id, feature_id, genotypes, gene_id_genotypes, snp_id, sample_id, BPPARAM = BiocParallel::MulticoreParam(workers = 1)){
  
  stopifnot( class( counts ) %in% c("matrix", "data.frame"))
  counts <- as.matrix(counts)
  stopifnot( mode( counts ) %in% c("numeric"))

  stopifnot( class( gene_id ) %in% c("character", "factor"))
  stopifnot( class( feature_id ) %in% c("character", "factor"))
  stopifnot( length(gene_id) == length(feature_id) )
  stopifnot(nrow(counts) == length(feature_id))
  
  stopifnot( class( genotypes ) %in% c("matrix", "data.frame"))
  genotypes <- as.matrix(genotypes)
  stopifnot( mode( genotypes ) %in% c("numeric"))
  stopifnot(all(genotypes %in% c(-1, 0, 1, 2, NA)))
  
  stopifnot( class( gene_id_genotypes ) %in% c("character", "factor"))
  stopifnot( class( snp_id ) %in% c("character", "factor"))
  stopifnot( length(gene_id_genotypes) == length( snp_id ) )
  stopifnot(nrow(genotypes) == length( snp_id ))
  
  stopifnot( class( sample_id ) %in% c("character", "factor"))
  stopifnot(ncol(counts) == ncol(genotypes))
  stopifnot(ncol(genotypes) == length(sample_id))
  
  ### keep genes that are in counts and in genotypes
  genes2keep <- gene_id %in% gene_id_genotypes
  counts <- counts[genes2keep, , drop = FALSE]
  gene_id <- gene_id[genes2keep]
  feature_id <- feature_id[genes2keep]
  
  genes2keep <- gene_id_genotypes %in% gene_id
  genotypes <- genotypes[genes2keep, , drop = FALSE]
  gene_id_genotypes <- gene_id_genotypes[genes2keep]
  snp_id <- snp_id[genes2keep]

  ### order genes in counts and in genotypes
  if(class(gene_id) == "character")
    gene_id <- factor(gene_id, levels = unique(gene_id))
  
  order_counts <- order(gene_id)
  counts <- counts[order_counts, , drop = FALSE]
  gene_id <- gene_id[order_counts]
  feature_id <- feature_id[order_counts]
  gene_id_genotypes <- factor(gene_id_genotypes, levels = levels(gene_id))
  
  order_genotypes <- order(gene_id_genotypes)
  genotypes <- genotypes[order_genotypes, , drop = FALSE]
  gene_id_genotypes <- gene_id_genotypes[order_genotypes]
  snp_id <- snp_id[order_genotypes]

  colnames(counts) <- sample_id
  rownames(counts) <- feature_id
  
  colnames(genotypes) <- sample_id
  rownames(genotypes) <- snp_id

  inds_counts <- 1:length(gene_id)
  names(inds_counts) <- feature_id
  partitioning_counts <- split(inds_counts, gene_id)
  
  inds_genotypes <- 1:length(gene_id_genotypes)
  names(inds_genotypes) <- snp_id
  partitioning_genotypes <- split(inds_genotypes, gene_id_genotypes)

  counts <- new( "MatrixList", unlistData = counts, partitioning = partitioning_counts)
  genotypes <- new( "MatrixList", unlistData = genotypes, partitioning = partitioning_genotypes)
  
  ### keep unique genotypes and create info about blocs
  
  inds <- 1:length(genotypes)
  
  blocks <- MatrixList(BiocParallel::bplapply(inds, function(g){
    # g = 1
    
    genotypes_df <- data.frame(t(genotypes[[g]]))
    matching_snps <- match(genotypes_df, genotypes_df)
    oo <- order(matching_snps, decreasing = FALSE)
    block_id <- paste0("block_", as.numeric(factor(matching_snps)))
    snp_id <- colnames(genotypes_df)
    blocks_tmp <- cbind(block_id, snp_id)
    
    return(blocks_tmp[oo, , drop = FALSE])
    
  }, BPPARAM = BPPARAM))
  
  names(blocks) <- names(genotypes)
  
  genotypes_u <- MatrixList(BiocParallel::bplapply(inds, function(g){
    # g = 1
    genotypes_tmp <- unique(genotypes[[g]])
    rownames(genotypes_tmp) <- paste0("block_", 1:nrow(genotypes_tmp))
    return(genotypes_tmp)
    
  }, BPPARAM = BPPARAM))
  
  names(genotypes_u) <- names(genotypes)
  samples <- data.frame(sample_id = sample_id)
  data <- new("dmSQTLdata", counts = counts, genotypes = genotypes_u, blocks = blocks, samples = samples)
  
  return(data)
  
}



######################################



#' @rdname dmSQTLdata
#'  @param gene_ranges \code{\linkS4class{GRanges}} object with gene location. It must contain gene names when calling names().
#'  @param snp_ranges \code{\linkS4class{GRanges}} object with SNP location. It must contain SNP names when calling names().
#'  @param window Size of a down and up stream window, which is defining the surrounding for a gene. Only SNPs that are located within a gene or its surrounding are considered in the sQTL analysis. 
#'  @export
dmSQTLdataFromRanges <- function(counts, gene_id, feature_id, gene_ranges, genotypes, snp_id, snp_ranges, sample_id, window = 5e3, BPPARAM = BiocParallel::MulticoreParam(workers = 1)){

  stopifnot( class( counts ) %in% c("matrix", "data.frame"))
  counts <- as.matrix(counts)
  stopifnot( mode( counts ) %in% c("numeric"))
  
  stopifnot( class( gene_id ) %in% c("character", "factor"))
  stopifnot( class( feature_id ) %in% c("character", "factor"))
  stopifnot( length(gene_id) == length( feature_id ) )
  stopifnot(nrow(counts) == length(feature_id))
  
  stopifnot( class( genotypes ) %in% c("matrix", "data.frame"))
  genotypes <- as.matrix(genotypes)
  stopifnot( mode( genotypes ) %in% c("numeric"))
  stopifnot(all(genotypes %in% c(-1, 0, 1, 2, NA)))
  
  stopifnot( class( snp_id ) %in% c("character", "factor"))
  stopifnot(nrow(genotypes) == length( snp_id ))
  
  stopifnot( class( sample_id ) %in% c("character", "factor"))
  stopifnot(ncol(counts) == ncol(genotypes))
  stopifnot(ncol(genotypes) == length(sample_id))
  
  stopifnot(class(gene_ranges) == "GRanges")
  stopifnot(class(snp_ranges) == "GRanges")
  stopifnot(!is.null(names(snp_ranges)))
  stopifnot(!is.null(names(gene_ranges)))
  
  stopifnot(is.numeric(window))
  stopifnot(window >= 0)

  rownames(genotypes) <- snp_id
  gene_ranges <- GenomicRanges::resize(gene_ranges, GenomicRanges::width(gene_ranges) + 2 * window, fix = "center")
  
  ## Match genes and SNPs
  variantMatch <- GenomicRanges::findOverlaps(gene_ranges, snp_ranges, select = "all")
  
  q <- GenomicRanges::queryHits(variantMatch)
  s <- GenomicRanges::subjectHits(variantMatch)
  
  genotypes <- genotypes[s, ]
  snp_id <- snp_id[s]
  gene_id_genotypes <- names(gene_ranges)[q]

  data <- dmSQTLdata(counts = counts, gene_id = gene_id, feature_id = feature_id, genotypes = genotypes, gene_id_genotypes = gene_id_genotypes, snp_id = snp_id, sample_id = sample_id, BPPARAM = BPPARAM)
  
  return(data)
  
}


################################################################################
### dmFilter
################################################################################


#' @param minor_allele_freq Minimal number of samples for the minor allele presence.
#' @param BPPARAM Parallelization method used by \code{\link[BiocParallel]{bplapply}}.
#' @details 
#' 
#' In sQTL analysis, \code{min_samps_gene_expr} could be equal to the total sample size. For some genes, missing values are present in the data. Thus, this number should indicate the minimal number of samples that you allow to include in the downstream analysis. For each gene, samples with gene expression lower than \code{min_gene_expr} have \code{NA}s assigned. This means that such samples are not considered in the sQTL analysis. For example, if \code{min_samps_gene_expr = 70} and \code{min_gene_expr = 1}, only genes with expression of at least 1 cpm in at least 70 samples are kept, and samples with expression lower than 1 cpm are skipped in the analysis. \code{minor_allele_freq} should indicate the minimal number of samples for the minor allele frequency. Usually, it is equal to 5\% of total samples. \code{min_samps_feature_prop} should be equal to \code{minor_allele_freq}.
#' 
#' @rdname dmFilter
#' @export
setMethod("dmFilter", "dmSQTLdata", function(x, min_samps_gene_expr = 70, min_gene_expr = 1, min_samps_feature_prop = 5, min_feature_prop = 0.1, max_features = Inf, minor_allele_freq = 5, BPPARAM = BiocParallel::MulticoreParam(workers = 1)){
  
  stopifnot(min_samps_gene_expr >= 0 && min_samps_gene_expr <= nrow(x@counts))
  stopifnot(min_gene_expr >= 0)
  stopifnot(min_samps_feature_prop >= 0 && min_samps_feature_prop <= nrow(x@counts))
  stopifnot(min_feature_prop >= 0 && min_feature_prop <= 1)
  stopifnot(max_features >= 2)
  stopifnot(minor_allele_freq >= 1 && minor_allele_freq <= floor(nrow(x@counts)/2))
  
  
  data_filtered <- dmSQTL_filter(counts = x@counts, genotypes = x@genotypes, blocks = x@blocks, samples = x@samples, min_samps_gene_expr = min_samps_gene_expr, min_gene_expr = min_gene_expr, min_samps_feature_prop = min_samps_feature_prop, min_feature_prop = min_feature_prop, max_features = max_features, minor_allele_freq = minor_allele_freq, BPPARAM = BPPARAM)
  
  return(data_filtered)
  
  
})


################################################################################
### plotData
################################################################################


#' @examples 
#' ### sQTL analysis
#'
#' d <- dataSQTL_dmSQTLdata
#' plotData(d)
#'
#' @seealso \code{\link{dataSQTL_dmSQTLdata}}
#' @rdname plotData
#' @export
setMethod("plotData", "dmSQTLdata", function(x, out_dir = NULL){
  
  dmSQTL_plotData(counts = x@counts, genotypes = x@genotypes, blocks = x@blocks, out_dir = out_dir)
  
})





























