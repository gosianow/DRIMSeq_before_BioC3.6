%\VignetteIndexEntry{Differential splicing and sQTL analyses in RNA-seq with 'DRIMSeq' package}
%\VignettePackage{DRIMSeq}
%\VignetteEngine{knitr::knitr}

\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}


<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex(use.unsrturl=FALSE)
@


\bioctitle[Differential splicing and sQTL analyses in RNA-seq with \Rpackage{DRIMSeq} package]{DRIMSeq: Dirichlet-multinomial framework for differential splicing and sQTL analyses in RNA-seq.}
%% also: \bioctitle{Title used for both header and title page}
%% or... \title{Title used for both header and title page}
\author{Malgorzata Nowicka\footnote{gosia.nowicka@uzh.ch}, Mark Robinson}

% \Rpackage{}
% \Biocpkg{IRanges} 
% \Biocexptpkg{parathyroidSE} 
% \CRANpkg{data.table}

% \Rfunction{findOverlaps} for functions findOverlaps.
% \Robject{olaps} for variables olaps.
% \Rclass{GRanges} when referring to a formal class GRanges.
% \Rcode{log(x)} for R code, log(x).

% \emph{}

\begin{document}
\maketitle 
\noindent This vignette describes version \Sexpr{packageDescription("DRIMSeq")$Version} of the \Rpackage{DRIMSeq} package.
\tableofcontents


<<setup_knitr, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(cache = TRUE, tidy = FALSE, tidy.opts = list(blank = FALSE), highlight=FALSE, out.width = "7cm", out.height = "7cm", fig.align = "center")
@



%------------------------------------------------------------------------------
%	Introduction
%------------------------------------------------------------------------------

\section{Overview of Dirichlet-multinomial model}

In the \Rpackage{DRIMSeq} package we implemented a Dirichlet-multinomial framework that can be used for modeling various multivariate count data with the interest in finding the instances where the ratios of observed features are different between the experimental conditions. Such model can be applied, for example, in differential splicing or sQTL analysis where the multivariate features are transcripts or exons of a gene. Depending on the type of counts that are used in the analysis, you can test for differential splicing at the level of transcript or exon ratio changes. The implementation of Dirichlet-multinomial model in \Rpackage{DRIMSeq} package is customized for differential splicing and sQTL analyses, but the data objects used \Rpackage{DRIMSeq} can contain different types of counts, and thus, other types of multivariate differential analysis between groups can be performed.

The statistical details of \Rpackage{DRIMSeq} are presented in our paper \fixme{citation to DRIMSeq paper}. In short, the method consists of three statistical steps. First, we use the profile likelihood to estimate the dispersion, i.e., the variability of feature ratios between samples (replicates) within conditions. Dispersion is needed in order to find the significant changes in features ratios between conditions which should be sufficiently stronger than the changes/variability within conditions. Second, we use the maximum likelihood to estimate the full model (estimated in every group/condition separately) and null model (estimated from all data) proportions and its corresponding likelihoods. Finally, we use the likelihood ratio statistic to test for the differences between feature proportions in different groups to identify the differentially spliced genes (differential splicing analysis) or the sQTLs (sQTL analysis).


\section{Hints for DRIMSeq pipelines}

In this vignette, we present how one could perform differential splicing analysis and sQTL analysis with \Rpackage{DRIMSeq} package. We use small subsets of data so that you can run the whole pipelines within few minutes in \R{} on a single core computer. 

Both pipelines consist of the initial steps where objects containing the data for the analysis are initiated and then filtered. Functions used for this purpose, such as \Rfunction{dmDSdata} or \Rfunction{dmSQTLdata} and \Rfunction{dmFilter}, have some parameters (like \Robject{counts}, \Robject{gene\_id}, \Robject{min\_samps\_gene\_expr}, etc.) for which no default values are predefined. These parameters must be specified by user in order to proceed with the pipeline.

Functions \Rfunction{dmDispersion}, \Rfunction{dmFit} and \Rfunction{dmTest}, which perform the actual statistical analysis described above, require that only one parameter \Robject{x} containing the data is specified by user. These functions have many other parameters available for tweaking, but they do have default values, which were chosen based on many real data analysis.

Some of the steps are quite time consuming, especially the dispersion estimation, where proportions of each gene are refitted for different dispersion parameters. To speed up the calculations, we have implemented in many functions a parallelization approach from \Biocpkg{BiocParallel}. Thus, if possible, we recommend to increase the number of workers in \Robject{BPPARAM}. 






%------------------------------------------------------------------------------
%	Differential splicing analysis work-flow
%------------------------------------------------------------------------------

\section{Differential splicing analysis work-flow}

% 
% \subsection{Preparing table of counts}
% 
% As shown by Soneson et al. \cite{Soneson2015}, using different counts in differential splicing analysis has big influence on the results. 
% 
% 
% Different methods (reference to Charlotte's paper) require different steps like alignment 
% 
% Exonic bin counts: HTSeq, featureCounts, 
% Transcript expected counts: kallisto, RSEM, BitSeq
% 


\subsection{Example data}

To demonstrate the usage of \Rpackage{DRIMSeq} in differential splicing analysis, we will use a \emph{pasilla} data set produced by Brooks et al. \cite{Brooks2011}. The aim of their study was to identify exons that are regulated by \emph{pasilla} protein, the Drosophila melanogaster ortholog of mammalian NOVA1 and NOVA2 which are one of the well studied splicing factors. In their RNA-seq experiment the libraries were prepared from 7 biologically independent samples: 4 control samples and 3 samples in which \emph{pasilla} was knocked-down. The libraries were sequenced on Illumina Genome Analyzer II using single-end and paired-end sequencing and different read lengths. The RNA-seq data can be downloaded from the NCBIâ€™s Gene Expression Omnibus (GEO) under the accession number GSE18508. In the examples below, we use a subset of the \software{HTSeq} counts available in \Biocexptpkg{pasilla} package, where you can find all the steps needed, for processing the GEO data, to get a table with exonic bin counts. 


\subsection{Differential splicing analysis with DRIMSeq package}

In oder to do the analysis, we have to create a \Rclass{dmDSdata} object, which contains feature counts and information about grouping samples into conditions. With each step of the pipeline, additional elements are added to this object. So that, at the end of the analysis, the object contains results from all the steps, such as dispersion estimates, proportions estimates, likelihood ratio statistics, p-values, adjusted p-values. As new elements are added, the object also changes its name \Rclass{dmDSdata} $->$ \Rclass{dmDSdispersion} $->$ \Rclass{dmDSfit} $->$ \Rclass{dmDStest}, but every following one inherits slots and methods available for the previous one. 



\subsubsection{Loading pasilla data into R}

The counts obtained from \software{HTSeq} are saved in separate text files for each sample. We want to put them together into one data frame. 


<<DSpasilla1>>=
library(pasilla)

data_dir  <- system.file("extdata", package="pasilla")
count_files <- list.files(data_dir, pattern="fb.txt$", full.names=TRUE)
count_files

## Read the HTSeq files into R
htseq_list <- lapply(1:length(count_files), function(i){
  htseq <- read.table(count_files[i], header = FALSE, as.is = TRUE)
  colnames(htseq) <- c("group_id", gsub("fb.txt", "", strsplit(count_files[i], 
    "extdata/")[[1]][2]))
  return(htseq)
})

## Merge them into one data frame
htseq_counts <- Reduce(function(...) merge(..., by = "group_id", all=TRUE, 
  sort = FALSE), htseq_list)

## Remove the summary elements
tail(htseq_counts)
htseq_counts <- htseq_counts[!grepl(pattern = "_", htseq_counts$group_id), ]

@


The exon bin IDs produced by \software{HTSeq} consist of the gene IDs and the bin number separated by colon. To create the \Rclass{dmDSdata} object, we need a vector of gene IDs and a vector of feature IDs, here bin IDs.


<<DSpasilla2>>=
group_split <- limma::strsplit2(htseq_counts[, 1], ":")
@



Finally, load the \Rpackage{DRIMSeq} package.

<<DSlibrary>>=
suppressPackageStartupMessages(library(DRIMSeq))
@


Create a \Rcode{dmDSdata} object (saved as variable \Robject{d}), which contains counts and information about samples such as sample IDs and a variable \Robject{group} defining the experimental groups/conditions. When printing variable \Robject{d}, you can see its class, size and which accessor methods can be applied. For \Rcode{dmDSdata} object, there are two methods which return data frames with counts and samples.  


<<DSdmDSdata_create>>=
d <- dmDSdata(counts = htseq_counts[, -1], gene_id = group_split[, 1], 
  feature_id = group_split[, 2], sample_id = colnames(htseq_counts)[-1], 
  group = gsub("[1-4]", "", colnames(htseq_counts)[-1]))
d
head(counts(d), 3)
head(samples(d), 3)
@

You can also make a data summary plot, which is a histogram of the number of features per gene. There are genes, that have nearly 100 of exonic bins. 

<<DSdmDSdata_plot>>=
plotData(d)
@


To make the analysis runnable within this vignette, we want to keep only a small subset of genes, which is defined in the following file.

<<DSdmDSdata_subset>>=
genes_subset = readLines(file.path(data_dir, "geneIDsinsubset.txt"))
d <- d[names(d) %in% genes_subset, ]
d
plotData(d)
@

After subsetting, \Robject{d} contains counts for $46$ genes.


\subsubsection{Filtering}
\label{DS_filtering}

Filtering of genes and features with low expression improves the performance of Dirichlet-multinomial model. Genes may have many features that are expressed very lowly (so that even if there was any differential expression, it would not be biologically significant) or not expressed at all. Removing such features from the analysis has two effects. First, it reduces the number of parameters (proportions) to estimate. Second, improves the estimation of dispersion \fixme{Do simulation}. However, too stringent filtering may remove genes and features where the differential changes happen, and, in consequence, lead to loss of power. 

Thus, finding an optimal filter is a challenge. In differential splicing analysis, we recommend to adjust the filtering parameters according to the number of replicates per condition. At the feature level, we suggest using \Robject{min\_samps\_feature\_prop} equal to the minimal number of replicates in any of the conditions. For example, in \emph{pasilla} assay with 3 knock-down and 4 control samples, we would set this parameters to 3. Like this, we allow a situation where a feature (here, an exonic bin) is expressed in one condition but may not be expressed at all in another one. The level of feature expression is controlled by \Robject{min\_feature\_prop}. Our default value is set up to 0.01, which means that only the features with ratio of at least 1\% in 3 samples are kept. 

Filtering at the gene level ensures that the observed feature ratios have some minimal reliability. Although, Dirichlet-multinomial model works on feature counts, and not on feature ratios, which means that it gives more confidence to the ratios based on 100 versus 500 reads than 1 versus 5, a minimal filtering for the gene expression removes the genes with mostly zero counts and reduces the number of tests in multiple test correction. The default value that we propose is \Rcode{min\_samps\_gene\_expr = 3} and \Rcode{min\_gene\_expr = 1}, which means that only genes that are expressed at the level of 1 cpm in at least 3 samples are kept for the downstream analysis.


<<DSdmFilter>>=
# Check what is the minimal number of replicates per condition
table(samples(d)$group)

d <- dmFilter(d, min_samps_gene_expr = 6, min_samps_feature_expr = 3,
  min_samps_feature_prop = 3)
plotData(d)
@

\subsubsection{Dispersion estimation}
\label{DS_dispersion_estimation}

Ideally, we would like to get accurate dispersion estimates for every gene, which is problematic when analyzing small sample size data sets because dispersion estimates become inaccurate when the sample size decreases, especially for lowly expressed genes. As an alternative, we could assume that all the genes have the same dispersion and based on all the data we could calculate a common dispersion, which is less inaccurate. However, such assumption is quite unrealistic. Moderated dispersion is a trade-off between gene-wise and common dispersion. The moderated estimates are a weighted combination of common and individual dispersion and we recommend such approach when analyzing small sample size data sets.

At this step three values may be calculated: mean expression of genes, common dispersion and gene-wise dispersions. 
In the default setting all of them are computed and common dispersion is used as an initial value in the grid approach to estimate moderated gene-wise dispersions, which are shrunk toward the common dispersion.

This step of our pipeline is the most time consuming, thus consider increasing the number of workers in \Robject{BPPARAM}. 

<<DSdmDispersion>>=
d <- dmDispersion(d, BPPARAM = BiocParallel::MulticoreParam(workers = 2))
d
head(mean_expression(d), 3)
common_dispersion(d)
head(genewise_dispersion(d), 3)
@

To inspect the behaviour of dispersion estimates, you can plot them against the mean gene expression. Here, the effect of shrinking is not so well visible because our data set is very small. To see how it works on real data sets, go to our paper \fixme{citation to DRIMSeq paper}.

<<DSdmDispersion_plot>>=
plotDispersion(d)
@


\subsubsection{Proportions estimation}

In this step, we estimate the full model proportions, meaning, that transcript or exon proportions are estimated for each condition separately. You can access this estimates and the corresponding statistics, such as log-likelihoods, with \Rfunction{proportions} and \Rfunction{statistics} functions, respectively.



<<DSdmFit, out.width = "16cm", fig.width = 16>>=
d <- dmFit(d, BPPARAM = BiocParallel::MulticoreParam(workers = 1))
d

head(proportions(d), 3)
head(statistics(d), 3)
@


\subsubsection{Testing for differential splicing}
\label{DS_testing}

Calling the \Rfunction{dmTest} function results in two things. First, null model proportions, i.e., feature ratios based on pooled (no grouping into conditions) counts, are estimated. Second, likelihood ratio statistic is used to test for the difference between feature proportions in different groups to identify the differentially spliced genes. 

By default, a parameter \Rcode{compared\_groups} in \Rfunction{dmTest} equals to \Rcode{1:nlevels(samples(x)\$group)}, which means that we test for differences in splicing between any of the groups specified in \Rcode{samples(d)\$group}. In \emph{pasilla} example, there are only two conditions, and there is only one comparison that can be done. In the case where the grouping variable has more that two levels, you could be interested in the pair-wise comparisons, which you can specify with \Robject{compared\_groups} parameter. 

Now, if you call \Rfunction{proportions} or \Rfunction{statistics} function, results of null estimation are added to the previous data frames.

<<DSdmTest>>=
d <- dmTest(d, BPPARAM = BiocParallel::MulticoreParam(workers = 1))
d

head(proportions(d), 3)
head(statistics(d), 3)

@

To obtain the results of likelihood ratio test, you have to call the function \Rfunction{results}, which returns a data frame with likelihood ratio statistics, degrees of freedom, p-values and Benjamini and Hochberg adjusted p-values for each gene. 


<<DSdmTest_results>>=
head(results(d), 3)
@

You can plot the histogram of p-values.

<<DSdmTest_plot>>=
plotTest(d)
@

For genes of interest, you can make plots (bar plots, line plots, box plots, ribbon plots) of observed and estimated with Dirichlet-multinomial model feature ratios. Estimated proportions are marked with diamond shapes. Here, we plot the results for the top significant gene.

<<DSdmLRT_plotFit, out.width = "16cm", fig.width = 16>>=
res <- results(d)
res <- res[order(res$pvalue, decreasing = FALSE), ]
gene_id <- res$gene_id[1]

plotFit(d, gene_id = gene_id)
plotFit(d, gene_id = gene_id, plot_type = "lineplot")
plotFit(d, gene_id = gene_id, plot_type = "ribbonplot")

@




%------------------------------------------------------------------------------
%	sQTL analysis work-flow
%------------------------------------------------------------------------------


\section{sQTL analysis work-flow}

\subsection{Example data}

For the sQTL analysis, we use data from the GEUVADIS project \cite{Lappalainen2013}, where 462 RNA-Seq samples from lymphoblastoid cell lines were obtained. The genome sequencing data of the same individuals is provided by the 1000 Genomes Project. The samples in this project come from five populations: CEPH (CEU), Finns (FIN), British (GBR), Toscani (TSI) and Yoruba (YRI). We use transcript quantifications (expected counts from FluxCapacitor) and genotypes available on the GEUVADIS project website \url{http://www.ebi.ac.uk/Tools/geuvadis-das/}, and the Gencode v12 gene annotation available on \url{http://www.gencodegenes.org/releases/12.html}. 

In order to make the vignette runnable, we do the \Rpackage{DRIMSeq} analysis on subsets of bi-allelic SNPs and transcript expected counts for CEPH population (91 individuals) that correspond to 50 randomly selected genes from chromosome 19. In the next section, we present how this subsets were obtained.  


\subsection{GEUVADIS data preprocessing}

This section shows how you can prepare the GEUVADIS data for the analysis with \Rpackage{DRIMSeq}. It preprocesses counts and genotypes for all the populations. At the end, it generates subsets used in examples and \Rpackage{DRIMSeq} pipeline presented further in this vignette. The \R{} code in this section does not run when the vignette is generated, mainly because it takes some time, but it is executable. 

In the sQTL analysis, we want to identify genetic variants (here, bi-allelic SNPs) that are associated with changes in splicing. Such SNPs are then called splicing quantitative trait locies (sQTLs).  

Ideally, we would like to test the associations of every SNP with every gene. However, such approach would be very costly computationally and in terms of multiple testing correction. Under the assumption that SNPs that directly affect splicing are likely to be placed in the close surrounding of genes, we test only SNPs that are located within the gene body and within some range upstream and downstream the gene.  

In order to find out which SNPs should be tested with which genes, we need to know the location of genes. We can get it from the GFT file with Gencode v12 gene annotation available on \url{http://www.gencodegenes.org/releases/12.html}. Let's save this GFT file in \Rcode{geuvadis\_annotation/gencode.v12.annotation.gtf}. We can import it into \R{} and extract locations of protein coding genes with the following code.

<<eval=FALSE>>=
### main path where the data is saved
data_dir <- "."

library(GenomicRanges)
library(rtracklayer)
library(limma)

### prepare annotation
gtf0 <- import(paste0(data_dir, "geuvadis_annotation/gencode.v12.annotation.gtf"))

# keep protein coding genes
keep_index <- mcols(gtf0)$gene_type == "protein_coding" & mcols(gtf0)$type == "gene" 
gtf <- gtf0[keep_index]
# remove 'chr' from the chromosome names
seqlevels(gtf) <- gsub(pattern = "chr", replacement = "", x = seqlevels(gtf))
# create BED file with gene location
genes_bed <- data.frame(chr = seqnames(gtf), start =  start(gtf), end = end(gtf), 
   geneId = mcols(gtf)$gene_id)

dir.create(paste0(data_dir, "annotation"))
write.table(genes_bed, paste0(data_dir, "annotation/genes.bed"), quote = FALSE, 
   sep = "\t", row.names = FALSE, col.names = FALSE)
@


From \url{http://www.ebi.ac.uk/arrayexpress/files/E-GEUV-1/analysis_results/}, we can download a file with information about samples \Rcode{E-GEUV-1.sdrf.txt} and a file with transcript quantifications \Rcode{GD660.TrQuantCount.txt}. Let's save them in \Rcode{geuvadis\_analysis\_results/} folder. 

We use \Robject{samples} to keep the names of the samples and the population they come from.

<<eval=FALSE>>=
### prepare samples
samples <- read.table(paste0(data_dir, "geuvadis_analysis_results/E-GEUV-1.sdrf.txt"), 
    header = T, sep="\t", as.is=TRUE)

samples <- samples[c("Assay.Name", "Characteristics.population.")]
samples <- unique(samples)

dim(samples)
table(samples$Characteristics.population.)

colnames(samples) <- c("sample_id", "population")
samples$sample_id_short <- strsplit2(samples$sample_id, "\\.")[,1]

@


File \Rcode{GD660.TrQuantCount.txt} contains quantification for all the populations. We split this table by population and keep the samples specified in data frame \Robject{samples}.

<<eval = FALSE>>=
### prepare counts
expr_all <- read.table(paste0(data_dir, "geuvadis_analysis_results/GD660.TrQuantCount.txt"), 
   header = T, sep="\t", as.is = TRUE)

dim(expr_all)

expr_all <- expr_all[, c("TargetID", "Gene_Symbol", samples$sample_id)]
# use short names
colnames(expr_all) <- c("trId", "geneId", samples$sample_id_short)

dir.create(paste0(data_dir, "expression"))

for(i in unique(samples$population)){
  
  expr <- expr_all[, c("trId", "geneId", samples$sample_id_short[samples$population == i])]
  write.table(expr, paste0(data_dir, "expression/TrQuantCount_",i,".tsv"), 
     quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
  
}

@

The VCF files with genotypes are available on \url{http://www.ebi.ac.uk/arrayexpress/files/E-GEUV-1/genotypes/} in the compressed format. Let's save them in \Rcode{geuvadis\_genotypes/} folder. We can load them into \R{} using the \Biocpkg{VariantAnnotation} package. To do so, we have to first "big zip" them with \Rfunction{bgzip} and create indexes with \Rfunction{indexTabix}.


<<eval = FALSE>>=
library(Rsamtools)
library(VariantAnnotation)
library(tools)

files <- list.files(path = paste0(data_dir, "geuvadis_genotypes"), 
   pattern = "genotypes.vcf.gz", full.names = TRUE, include.dirs = FALSE)

## bigzip and index the vcf files
for(i in 1:length(files)){
  zipped <- bgzip(files[i])
  idx <- indexTabix(zipped, format = "vcf")
}
@

We are interested in bi-allelic SNPs that lay within a 5000 bases surrounding of genes. Additionally, we want to convert the genotype information into 0 for ref/ref, 1 for ref/not ref, 2 for not ref/not ref, -1 or NA for missing values. Newly encoded genotypes are saved as text files, one file for each chromosome and population. 

<<eval = FALSE>>=
### prepare genotypes
# extended gene ranges
window <- 5000
gene_ranges <- resize(gtf, GenomicRanges::width(gtf) + 2 * window, fix = "center")

population <- unique(samples$population)
chr <- gsub("chr", "", strsplit2(files, split = "\\.")[, 2])

dir.create(paste0(data_dir, "genotypes"))

for(j in 1:length(population)){
  for(i in 1:length(files)){
    
    cat(population[j], chr[i], fill = TRUE)
    
    zipped <- paste0(file_path_sans_ext(files[i]), ".bgz")
    idx <- paste0(file_path_sans_ext(files[i]), ".bgz.tbi")
    tab <- TabixFile(zipped, idx)
    
    ## Explore the file header with scanVcfHeader
    hdr <- scanVcfHeader(tab)
    print(all(samples$sample_id_short %in% samples(hdr)))
    
    ## Read VCF file - SNPs for one population and within extended gene ranges
    gene_ranges_tmp <- gene_ranges[seqnames(gene_ranges) == chr[i]]
    param <- ScanVcfParam(which = gene_ranges_tmp, 
       samples = samples$sample_id_short[samples$population == population[j]])
    vcf <- readVcf(tab, "hg19", param)
    
    ## Keep only the bi-allelic SNPs
    # width of ref seq
    rw <- width(ref(vcf))
    # width of first alt seq
    aw <- unlist(lapply(alt(vcf), function(x) {width(x[1])}))
    # number of alternate genotypes
    nalt <- elementLengths(alt(vcf))
    # select only bi-allelic SNPs (monomorphic OK, so aw can be 0 or 1)
    snp <- rw == 1 & aw <= 1 & nalt == 1
    # subset vcf  
    vcfbi <- vcf[snp,]
    
    rowdata <- rowData(vcfbi)
    
    ## Convert genotype into a number of alleles different from reference
    geno <- geno(vcfbi)$GT
    geno01 <- geno
    geno01[,] <- -1
    geno01[geno %in% c("0/0", "0|0")] <- 0 # REF/REF
    geno01[geno %in% c("0/1", "0|1", "1/0", "1|0")] <- 1 # REF/ALT
    geno01[geno %in% c("1/1", "1|1")] <- 2 # ALT/ALT
    # geno01 should be integer, not character
    mode(geno01) <- "integer"
    
    genotypes <- unique(data.frame(chr = seqnames(rowdata), 
       start = start(rowdata), end = end(rowdata), snpId = rownames(geno01), 
       geno01, stringsAsFactors = FALSE))
    
    ## sorting SNPs by position
    genotypes <- genotypes[order(genotypes[,2]), ]
    
    write.table(genotypes, 
      paste0(data_dir, "genotypes/genotypes_", j, "_chr", chr[i], ".tsv"),
      quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
    
  }
}

@

Now, we show how the example data sets were generated. The lists of sample genes and SNPs are predefined in the files in \Rcode{extdata/} of this package.

<<eval = FALSE>>=
data_ex_dir <- system.file("extdata", package = "DRIMSeq")

genes_subset = readLines(file.path(data_ex_dir, "/gene_id_subset.txt"))
snps_subset = readLines(file.path(data_ex_dir, "/snp_id_subset.txt"))

@

<<eval = FALSE>>=
### Subset gene ranges
gene_bed <- read.table(paste0(data_dir, "annotation/genes.bed"), header = FALSE, 
    as.is = TRUE)
gene_bed <- gene_bed[gene_bed[, 4] %in% genes_subset, ]

write.table(gene_bed, paste0("genes_subset.bed"), quote = FALSE, 
    sep = "\t", row.names = FALSE, col.names = FALSE)

### Subset counts
counts <- read.table(paste0(data_dir, "expression/TrQuantCount_CEU.tsv"),
    header = TRUE, as.is = TRUE)
counts <- counts[counts$geneId %in% genes_subset, ]

write.table(counts, paste0("TrQuantCount_CEU_subset.tsv"), 
    quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)

### Subset genotypes
genotypes <- read.table(paste0(data_dir, "genotypes/genotypes_CEU_chr19.tsv"), 
    header = TRUE, sep = "\t", as.is = TRUE)
genotypes <- genotypes[genotypes$snpId %in% snps_subset, ]

write.table(genotypes, paste0("genotypes_CEU_subset.tsv"), 
   quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)
@




\subsection{sQTL analysis with DRIMSeq package}

Assuming you have gene annotation, feature counts and bi-allelic genotypes that are expressed in terms of the number of alleles different from the reference, the \Rpackage{DRIMSeq} work-flow for sQTL analysis is the same as for differential splicing. 

First, we have to create a \Rclass{dmSQTLdata} object, which contains feature counts and genotypes. Similarly as in differential splicing pipeline, results from every step are added to this object and at the end of the analysis, it contains dispersion estimates, proportions estimates, likelihood ratio statistics, p-values, adjusted p-values. As new elements are added, the object also changes its name \Rclass{dmSQTLdata} $->$ \Rclass{dmSQTLdispersion} $->$ \Rclass{dmSQTLfit} $->$ \Rclass{dmSQTLtest}. For every following object, slots and methods are inherited from the previous one. 


\subsubsection{Loading GEUVADIS data into R}

Load the \Rpackage{DRIMSeq} package.

<<SQTLlibrary>>=
suppressPackageStartupMessages(library(DRIMSeq))
@


Let's load the subsets of GEUVADIS data that are prepared for the demonstration of the \Rpackage{DRIMSeq} work-flow.
Feature counts, genotypes and gene annotation can be found in the \Rcode{extdata/} folder attached with this package. In order to find which SNPs are in the surrounding of genes we have to prepare \Rclass{GRanges} objects with gene and SNP locations. All this is done with the following code.

<<SQTLgeuvadis>>=
suppressPackageStartupMessages(library(GenomicRanges))
library(rtracklayer)

data_dir  <- system.file("extdata", package = "DRIMSeq")

# gene_ranges with names!
gene_ranges <- import(paste0(data_dir, "/genes_subset.bed"))
names(gene_ranges) <- mcols(gene_ranges)$name

counts <- read.table(paste0(data_dir, "/TrQuantCount_CEU_subset.tsv"),
   header = TRUE, sep = "\t", as.is = TRUE)

genotypes <- read.table(paste0(data_dir, "/genotypes_CEU_subset.tsv"),
   header = TRUE, sep = "\t", as.is = TRUE)

# snp_ranges with names!
snp_ranges <- GRanges(Rle(genotypes$chr), IRanges(genotypes$start,
   genotypes$end))
names(snp_ranges) <- genotypes$snpId

## Check if samples in count and genotypes are in the same order
all(colnames(counts[, -(1:2)]) == colnames(genotypes[, -(1:4)]))
sample_id <- colnames(counts[, -(1:2)])

@


In the sQTL analysis, an initial data object \Robject{d} is of \Robject{dmSQTLdata} class and, additionally to feature counts, it contains genotypes. 


<<SQTLdmSQTLdata_create>>=
d <- dmSQTLdataFromRanges(counts = counts[, -(1:2)], gene_id = counts$geneId,
   feature_id = counts$trId, gene_ranges = gene_ranges,
   genotypes = genotypes[, -(1:4)], snp_id = genotypes$snpId,
   snp_ranges = snp_ranges, sample_id = sample_id, window = 5e3,
   BPPARAM = BiocParallel::MulticoreParam(workers = 1))
d
@

In our sQTL analysis, we do not repeat tests for the SNPs that define the same grouping of samples. We identify SNPs with identical genotypes across the samples and assign them to blocks. Estimation and testing is done at the block level, but the returned results are extended to a SNP level by repeating the block statistics for each SNP that belongs to a given block. 

Here, the data summary plot produces three histograms: the number of features per gene, the number of SNPs per gene and the number of blocks per gene. Total number of tests done in this analysis is equal to the total number of blocks. You can use the \Rcode{multiplot} function from \url{http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/} to plot this three figures next to each other.

<<multiplot, echo = FALSE>>=
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
@


<<SQTLdmSQTLdata_plot, out.width = "16cm", fig.width = 16>>=
multiplot(plotlist = plotData(d), cols = 3)
@



\subsubsection{Filtering}

The filtering step eliminates genes and features with low expression, as in differential splicing analysis \ref{DS_filtering}. Additionally, it filters out the SNPs/blocks which do not define at least two genotypes where each of them is present in at least \Robject{minor\_allele\_freq} individuals. Usually, \Robject{minor\_allele\_freq} is equal to more or less 5\% of total sample size. \Robject{min\_samps\_feature\_prop} defines the minimal number of samples where feature has to be expressed at the level of minimum \Robject{min\_feature\_prop}. It should be equal to the size of the minimal group that can be created based on genotypes which is equal to \Robject{minor\_allele\_freq}. Like this, we allow a situation where a feature is expressed in one group, but may not be expressed at all in another one, which is a case of differential splicing. Because \Robject{min\_samps\_feature\_prop} is quite low in comparison to the total sample size, we can be more conservative about the \Robject{min\_feature\_prop} which is set to 0.1.

Ideally, we would like that genes were expressed at some minimal level in all samples because this would lead to better estimates of feature ratios. However, for some genes, missing values are present in the counts data, or genes are lowly expressed in some samples. Setting up \Robject{min\_samps\_gene\_expr} to 91 would exclude too many genes. We can be slightly less stringent by taking, for example, \Rcode{min\_samps\_gene\_expr = 70}.   


<<SQTLdmFilter, out.width = "16cm", fig.width = 16>>=
d <- dmFilter(d, min_samps_gene_expr = 70, min_samps_feature_expr = 5,
    min_samps_feature_prop = 5, minor_allele_freq = 5, 
    BPPARAM = BiocParallel::MulticoreParam(workers = 1))

multiplot(plotlist = plotData(d), cols = 3)
@


\subsubsection{Dispersion estimation}

As for differential splicing \ref{DS_dispersion_estimation}, \Rfunction{dmDispersion} may calculate three values: mean expression of genes, common dispersion and gene-wise dispersions. It has an additional parameter \Rcode{speed}. If \Rcode{speed = FALSE}, gene-wise dispersions are calculated per each gene-block. Such calculation may take a long time, since there can be hundreds of SNPs/blocks per gene. If \Rcode{speed} is set to \Rcode{TRUE}, there will be only one dispersion calculated per gene and it will be assigned to all the blocks matched with this gene. 

In the default setting, \Rcode{speed = TRUE} and common dispersion is used as an initial value in the grid approach to estimate gene-wise dispersions with NO moderation, since the sample size is quite big.


<<SQTLdmDispersion>>=
d <- dmDispersion(d, BPPARAM = BiocParallel::MulticoreParam(workers = 2))
d
plotDispersion(d)
@


\subsubsection{Proportions estimation}

Full model proportions are estimated for each gene-block pair.


<<SQTLdmFit>>=
d <- dmFit(d, BPPARAM = BiocParallel::MulticoreParam(workers = 1))
d
@


\subsubsection{Testing for sQTLs}

As in \ref{DS_testing}, \Rfunction{dmTest} function fits null model proportions and does the likelihood ratio test. 
To obtain the results, you have to call the function \Rfunction{results}, which returns a data frame with likelihood ratio statistics, degrees of freedom, p-values and Benjamini and Hochberg adjusted p-values for each gene-block/SNP pair. 


<<SQTLdmTest>>=
d <- dmTest(d, BPPARAM = BiocParallel::MulticoreParam(workers = 1))
d
head(results(d), 3)
plotTest(d)
@


You can plot the observed and estimated with Dirichlet-multinomial model feature ratios for the sQTLs of interest. When the sample size is big, we recommend using box plots as a \Rcode{plot\_type}. Here, we plot an sQTL with the lowest p-value.

<<SQTLplotFit, out.width = "16cm", fig.width = 16, warning = FALSE>>=
res <- results(d)
res <- res[order(res$pvalue, decreasing = FALSE), ]

gene_id <- res$gene_id[1]
snp_id <- res$snp_id[1]

plotFit(d, gene_id, snp_id)
plotFit(d, gene_id, snp_id, plot_type = "boxplot2", order = FALSE)
plotFit(d, gene_id, snp_id, plot_type = "ribbonplot")
@




\appendix
\clearpage
\begin{center}
{\Large\sffamily\bfseries\color{BiocBlue} APPENDIX} \addcontentsline{toc}{section}{APPENDIX}
\end{center}


%--------------------------------------------------
% Session information
%--------------------------------------------------

\section{Session information}


<<sessionInfo>>=
sessionInfo()
@

%--------------------------------------------------
% References
%--------------------------------------------------

\section{References}

\bibliographystyle{ieeetr}
\bibliography{DRIMSeq}


\end{document}